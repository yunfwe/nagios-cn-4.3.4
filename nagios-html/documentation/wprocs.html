<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nagios: Worker Processes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="wprocs">Worker Processes </a></h1><p>Everything related to worker processes.</p>
<p>[TOC]</p>
<h2><a class="anchor" id="philosophy">
Philosophy</a></h2>
<p>The idea behind separate worker processes is to achieve protected parallelization. Protected because a worker being naughty shouldn't affect the core process, and parallel because we use multiple workers. Ideally between 1.5 and 3 per CPU core available to us.</p>
<p>Workers are free-standing processes, kept small, and with no knowledge about Nagios' object structure or logic. The reason for this is that small processes can achieve a lot more fork()s per second than large processes (800/sec for a 300MB process against 13900/sec for a 1MB process). While workers can (and do) grow a little bit in memory usage when it's running many checks in parallel, they will still be a lot smaller than the primar Nagios daemon, and the memory they occupy should be released once the checks they're running are done.</p>
<h2><a class="anchor" id="protocol">
Protocol</a></h2>
<p>Workers use a text-based protocol to communicate with workers. It's fairly simple and very easy to debug. The breakdown goes as follows: </p>
<ul>
<li>A request consists of a sequence of key/value pairs. </li>
<li>A key is separated from its value with an equal sign ('='). </li>
<li>A key/value pair is separated from the next key/value pair with a nul byte (''). </li>
<li>Each request is separated from the next with a message delimiter sequence made up by a one-byte followed by three nul bytes: "\1\0\0\0". </li>
<li>Keys cannot contain equal signs. underscores and numbers. </li>
<li>Values cannot contain nul bytes. </li>
<li>Neither keys nor values can contain the message delimiter. </li>
<li>A zero-length value is considered to be the empty string.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>Even though it's technically legal to put almost anything in the key field, you should stick to mnemonic names when extending the protocol and just use lower case letters and underscores. </dd>
<dd>
Keys are case sensitive. JOB_ID is *not* the same as job_id.</dd></dl>
<h3><a class="anchor" id="apis">
API's</a></h3>
<p>Worker processes communicate with Nagios using libnagios API's exclusively. Since you're looking at a subpage of the documentation for that documentation right now, I'll just assume you've found it. Although using the libnagios api's when writing a worker is completely optional, it's highly recommended.</p>
<p>The key API's to use are: </p>
<ul>
<li>nsock - for connecting to and communicating through the qh socket </li>
<li><a class="el" href="structkvvec.html" title="key/value vector struct This is the main component of the kvvec library">kvvec</a> - for parsing requests and building responses </li>
<li>worker - for utils and stuff nifty to have if you're a worker </li>
<li>runcmd - for spawning and reaping commands </li>
<li>squeue - for maintaining a queue of the running job's timeouts </li>
<li>iocache - for bulk-reading requests and parsing them </li>
<li>iobroker - for multiplexing between running tasks and the master nagios process.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>In particular, have a look at the "parse_command_kvvec()" and "finish_job()" functions in lib/worker.c. They will do a large part of the request/response handling for you.</dd></dl>
<h2><a class="anchor" id="registering">
Registering a worker - The handshake</a></h2>
<p>Workers register with Nagios through the queryhandler, using a query sent to the wproc handler. Since the query handler reserves the nul byte as a magic delimiter for its messages, this one time we use the semicolon instead, as is almost-standard in the internal-only queryhandlers. Typically, the default worker process registers with a query such as this: </p>
<div class="fragment"><pre class="fragment">
@wproc register name=Core Worker $pid;pid=$pid\0
</pre></div><p>Nagios will then respond with </p>
<div class="fragment"><pre class="fragment">
OK\0
</pre></div><p> followed by a stream of commands.</p>
<p>Nagios currently understands the following (short) list of special keys: </p>
<ul>
<li>pid - The pid of the worker process. Sometimes used to check if a worker is online </li>
<li>name - Used to set the name of the worker </li>
<li>max_jobs - Used to tell Nagios how many concurrent jobs this worker can handle </li>
<li>plugin - basename() or absolute path of specific plugins that this worker wants to handle checks for.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>plugin can be given multiple times. It is valid for a single single worker to say "plugin=check_snmp;plugin=check_iferrors", for example.</dd>
<dd>
Many workers can register for the same plugin(s). They will share the load in round-robin fashion.</dd></dl>
<p>Complete C-code for registering a generic worker with Nagios follows: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">int</span> nagios_core_worker(<span class="keyword">const</span> <span class="keywordtype">char</span> *path)
{
    <span class="keywordtype">int</span> sd, ret;
    <span class="keywordtype">char</span> response[128];

    is_worker = 1;

    set_loadctl_defaults();

    sd = <a class="code" href="nsock_8h.html#a698ebbdfe5e3589dd9e2d466d87ceb5a" title="Create or connect to a unix socket To control permissions on sockets when NSOCK_LISTEN...">nsock_unix</a>(path, <a class="code" href="nsock_8h.html#aaa52ee91165aeea3d09b1d857b6b4426" title="use tcp mode">NSOCK_TCP</a> | <a class="code" href="nsock_8h.html#a408ebfcac776e538f3b8ef3d7297d3c4" title="connect rather than create">NSOCK_CONNECT</a>);
    <span class="keywordflow">if</span> (sd &lt; 0) {
        printf(<span class="stringliteral">&quot;Failed to connect to query socket &apos;%s&apos;: %s: %s\n&quot;</span>,
               path, <a class="code" href="nsock_8h.html#adcaaf011dcd99b0d782cc2b89736f2cf" title="Grab an error string relating to nsock_unix().">nsock_strerror</a>(sd), strerror(errno));
        <span class="keywordflow">return</span> 1;
    }

    ret = <a class="code" href="nsock_8h.html#a0469978df30212122748624f95e9c472" title="Write a nul-terminated message to the socket pointed to by sd.">nsock_printf_nul</a>(sd, <span class="stringliteral">&quot;@wproc register name=Core Worker %d;pid=%d&quot;</span>, getpid(), getpid());
    <span class="keywordflow">if</span> (ret &lt; 0) {
        printf(<span class="stringliteral">&quot;Failed to register as worker.\n&quot;</span>);
        <span class="keywordflow">return</span> 1;
    }

    ret = read(sd, response, 3);
    <span class="keywordflow">if</span> (ret != 3) {
        printf(<span class="stringliteral">&quot;Failed to read response from wproc manager\n&quot;</span>);
        <span class="keywordflow">return</span> 1;
    }
    <span class="keywordflow">if</span> (memcmp(response, <span class="stringliteral">&quot;OK&quot;</span>, 3)) {
        read(sd, response + 3, <span class="keyword">sizeof</span>(response) - 4);
        response[<span class="keyword">sizeof</span>(response) - 2] = 0;
        printf(<span class="stringliteral">&quot;Failed to register with wproc manager: %s\n&quot;</span>, response);
        <span class="keywordflow">return</span> 1;
    }

    enter_worker(sd, start_cmd);
    <span class="keywordflow">return</span> 0;
}
</pre></div><p>The "enter_worker()" part actually refers to a libnagios function that lives in worker.c. The set_loadctl_defaults() call can be ignored. It's primarily intended to give sane defaults about how many jobs we can run, so we (in theory) can tell Nagios that we're swamped in case we run out of filedescriptors or child processes.</p>
<h3><a class="anchor" id="request">
Requests</a></h3>
<p>A complete request looks like this (with C-style format codes replaced with actual values, ofcourse): </p>
<div class="fragment"><pre class="fragment">
job_id=%d\0type=%d\0command=%s\0timeout=%u\0\1\0\0\0
</pre></div><p>Note that values can contain equal signs, but cannot contain nul bytes, and cannot contain the message delimiter sequence. By including nagios/lib/worker.h and using worker_ioc2msg() followed by worker_kvvec2buf_prealloc(), you will get a parsed key/value vector handed to you. Have a look in base/workers.c to see how it's done for the core workers.</p>
<h3><a class="anchor" id="responses">
Responses</a></h3>
<p>Once the worker is done running a task, it hands over the result to the master Nagios process and forgets it ever ran the job. The workers take no further action, regardless of how the task went. The exception is if the job timed out, or if the worker failed to even start the job, in which case it should report the error to Nagios and only *then* forget it ever got the job.</p>
<p>The response is identical to the request in formatting but differs in the understood keys. The request sent from Nagios to the worker must precede the other result variables. In particular, the job_id must be the first variable Nagios sees for it to parse the result as a job result rather than as something else.</p>
<p>The variables required for the response to a successfully executed job on a registered worker process are as follows: </p>
<ul>
<li>job_id - The job id (as received by Nagios) </li>
<li>type - The job type (as Nagios sent it) </li>
<li>start - Timeval struct for start value in $sec.$usec format </li>
<li>stop - Timeval struct for stop time in $sec.$usec format </li>
<li>runtime - Floating point value of runtime, in seconds </li>
<li>outstd - Output caught on stdout </li>
<li>outerr - Output caught on stderr </li>
<li>exited_ok - Boolean flag to denote if the job exited ok. A non-zero return code can still be achieved </li>
<li>wait_status - Integer, as set by the wait() family of system calls</li>
</ul>
<p>The following should only be present when the worker is unable to execute the check due to an error, or when it cannot provide all the variables required for a successfully executed job due to arbitrary system errors: </p>
<ul>
<li>error_msg - An error message generated by the worker process </li>
<li>error_code - The error code generated by the worker process</li>
</ul>
<p>error_code 62 (ETIME - Timer expired) is reserved and means that the job timed out. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>*never* invent error codes in the range 0-10000, since we'll want to reserve that for special cases.</dd></dl>
<p>The following are completely optional (for now): </p>
<ul>
<li>command - The command we executed </li>
<li>timeout - The timeout Nagios requested for this job </li>
<li>ru_nsignals - The ru_nsignals field from the rusage struct </li>
<li>ru_nswap - The ru_nswap field from the rusage struct </li>
<li>ru_minflt - The ru_minflt field from the rusage struct </li>
<li>ru_majflt - The ru_majflt field from the rusage struct </li>
<li>ru_stime - The ru_stime field from the rusage struct </li>
<li>ru_utime - The ru_utime field from the rusage struct </li>
<li>ru_inblock - The ru_inblock field from the rusage struct </li>
<li>ru_oublock - The ru_oublock field from the rusage struct</li>
</ul>
<p>The meaning of the fields of the rusage struct can be viewed in the section 2 man-page for the getrusage() system call. Normally, you would access it by executing the following command: </p>
<div class="fragment"><pre class="fragment">
man 2 getrusage
</pre></div><p> Note that most systems do not support all the fields of the rusage struct and may leave them empty if so.</p>
<h2><a class="anchor" id="logging">
Logging</a></h2>
<p>Worker processes can send events to the main Nagios process that will end up in the nagios.log file. The format is the same as that in requests and responses, but a log-message consists of a single key/value pair, where the key is always 'log'. Consequently, a request from a worker to the main process to log something looks like this: </p>
<div class="fragment"><pre class="fragment">
log=A random message that will get logged to nagios.log\0
</pre></div><p>It's worth noting that Nagios will prefix the message with the worker process name, so as to make grep'ing easy when debugging experimental workers.</p>
<h2><a class="anchor" id="xchgexample">
Protocol Exchange Example</a></h2>
<p>A register + execution of one job on a worker process will, with the standard Nagios core worker look like this, after the worker process has connected to the query handler socket but before it has sent anything. Note that the nul-bytes separating key/value pairs have been replaced with newline to enhance readability. Also note that this depicts only the required steps, which go as follows: </p>
<div class="fragment"><pre class="fragment">
Step 1, Worker:
  @wproc register name=Worker Hoopla;max_jobs=100;pid=6196\0
Step 2, Nagios:
  OK\0
Step 3, Nagios:
  job_id=0
  type=2
  timeout=60
  command=/opt/plugins/check_ping -H localhost -w 40%,100.0 -c 60%,200.0
  \1\0\0\0
Step 4, Worker:
  job_id=0
  type=2
  timeout=60
  start=1355231532.000123
  stop=1355231532.994343
  runtime=0.994120
  exited_ok=1
  outstd=OK: RTA: 12.6ms; PL: 0%|rta=12.6ms;100.0;200.0;0;; pl=0%;40;60
  wait_status=0
  outerr=
  \1\0\0\0
</pre></div><p> Steps 3 and 4 in this chain repeat indefinitely. </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 9 Sep 2017 for Nagios by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
